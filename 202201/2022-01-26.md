* 객체안에 데이터가 있고 데이터에대한 메서드들이 있고 

```python
a = sorted(a) 
==============
a.sort() 
여기서 a라는 주어가 객체다
```

* 객체의 클래스 객체의 속성 객체의 메소드 객체의 인스턴스
* 모든 클래스들은 타입이 타입이다 
* 메소드 : 클래스 내부에서 정의된 함수 
* == : 동등한(equal)  값인지 
* is : 동일한(identical) 객체를 바라보는지

* 인스턴스 메소드: 호출 시, 첫번째 인자로 인스턴스 자기자신이 전달됨 
* Person.test(p1) (내부적으로 실행되는 과정) 
* p1  // p1.test() // Person.test(p1) -> Person.test()는 안됨 (왜냐하면 클래스로 호출할 경우 클래스는 자기 자신을 넘겨주지 않기때문. 인스턴스만 자기 자신으로 넘겨줌)
* 객체 : 속성 + 메소드 
* 클래스도 변수와 메소드가있고 
* 인스턴스도 변수와 메소드가 있다. 
* 클래스 메소드는 클래스를 조작하기위한 아이니깐 첫번째 인자로 클래스를 호출 
* PascalCase : 클래스 이름 
* snake_case : 함수, 변수 이름 
* -> PEP8에서 얘기하고 있음 
* 인스턴스를 조작하고 싶어 -> 인스턴스메서드를 내부에 만들자 
* 클래스를 조작하고 싶어 -> 함수 내부에 클래스를 던져주도록 설계
* 스태틱 메소드: 클래스나 인스턴트를 조작할 생각은 없는데 함수를 쓸거야 
* 우리가 알던 함수는 기본적으로 로컬스코프, 내부에서 활용하고 싶으면 파라미터로 받도록 정의 
* 문자라는 클래스 안에 '' '1' 'justin' 등이 포함되는 것 
* 클래스도 local scope 
* 함수를 호출할 때 (ex) ch.greeting - > ch가 클래스 내부의 self로 들어감
* int 와 float 는 서로 포함관계가 아님 
*  함수의 정의와 호출을 헷갈리지말자 
*  함수내부에서 input값을 가지고 써야함! 
* 다중상속일때는 먼저 참조하는 것에 영향
* public access modifier : 어디서나 
* protected access modifier : 상속관계 
* pricate access modifier: 본인 
* property 데코레이터: 메서드를 속성처럼 쓸 수 있게 
* help() 기능 활용
* 