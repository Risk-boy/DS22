- 시간복잡도: 실행되는 명령문의 개수를 계산 
- 배열: 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
- 크기를 미리 정해놓고 배열을 만드는 경우가 빠르다
- 코드에는 정답이 없지만 형식에는 정답이 있다. 
- print(*arr)
- print문을 지울 때 여러줄을 지우지 않도록 주의! 
- 배열의 크기는 보통 백만개 이하
- 백만개가 넘어가는 것은 수식이나 이런걸 이용
- 코드를 외우기 보단 그림으로 단계를 이해해야한다
- O(n + k) 를 O(n)이라 쓰지 않는 이유는 k가 n보다 영향력이 더 클 수 있어서
- breakpoint 시험나옴!! 

```python
while num > 0;
	c[num % 10] += 1
	num //= 10
```

- 칸을 12개 만들어 놓는 이유: index9 를 편하게 쓰려고?(run과 triplete의 인덱스를 공유하려고)
- triplete 조사와 run 조사는 별개이기 때문에 if if 를 쓴것
- greedy 접근법은 같은 방법으로 계속 처리했을 때 해를 구할 수 있 방법
- min max 구할 때 첫번째값을 쓸 수 없는 경우: 합이 최대가 되거나 이런 경우에 
- sort만 쓰면 되는데 왜 버블 선택 삽입 힙 카운트 등을 쓰느냐?
- 각 소트별로 장점 단점 시간복잡도 구현원리 방법 등은 외우자!
- 구현력 증가를 위한 연습
- 구현력을 왜 증가 시키냐?! 
- im문제: 구현력, 시뮬레이션 for while 잘돌리기 + 재귀
- a형: dfs, bfs 기본 + 자료구조 알고리즘 
- 파이썬 기초문법 + for while문 연습많이하기 
- 알고리즘 성능평가: 빅오 표기법, 시간복잡도 계산 

- 알고리즘 성능은 시간복잡도, 공간복잡도로 평가한다. 
- 시간복잡도: 점근적 표기법(대략적인 계산)
- Timecomplexity = 기본연산 수행횟수 + 입력되는 data 를 종합적으로 고려해서 대략적으로 계산 
- 최선표기법, 평균표기법, 최악표기법 
- ps에서는 최악표기법을 채택 (최악의 수를 집어넣었다고 가정한뒤 비교)
- 최악표기법을 표현하는 방법이 빅오표기법(O: 오더라고 읽음)
- 이중 for문이라고 무조건 n^2의 오더를 갖는 것이 아니다! 
- log 밑은 2로 디폴트 
- O(logn) 의 속도는 bst에서 탐색 속도이다! 
- binary search tree 
- ps에서는 1초->1억 현실적으로는 3억~5억 
- 문제읽기->설계->구현->디버깅
- 문제읽기: 제한시간, n값 확인 ex) n<100,000인데 이중for문쓴다? 시간초과임
- (왜냐하면100억 -> 100초)
- 설계: 몇 중 for문을 쓸건지 정한 후 그에 맞는 알고리즘 방법을 찾아본다.
- -> n값의 범위만 봐도 어떤 알고리즘을 풀지 감이 온다(문제를 많이 풀어보면!)
- 문제 많이 풀어보세요...내 실력이 3이면 3~4.5 정도의 난이도를 문제를 반복해서 여러번 풀어봐야함
- 디버깅 꼭 많이 해주세요...
- 메타인지(내가 뭘 알고 뭘 모르는지) 직접 코드를 짜봐야함
- 한문제 더 푸는 것보다 오답나온것을 하루종일 디버깅 해보는것이 실력향상에 더 큰 도움이 된다!!
- dat(direct address table) (빠른 검색을 위한 자료구조) 
- 























