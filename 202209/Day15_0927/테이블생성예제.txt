[테이블생성]
create table 테이블명(컬럼명1   컬럼타입  [제약조건],컬럼명2  컬럼타입  [제약조건],.....);

 -  문자로시작(30자이내) : 영문 대소문자,숫자,특수문자( _ , $ , # ),한글
 -  중복되는 이름은 사용안됨
 -  예약어(create, table,column등)은 사용할수 없다
 -  자료형
    number :  number(전체자리,소수이하), number  ==> 숫자형(가변형)
    int    :  정수형 숫자(고정형)
    varchar/varchar2 :  문자,문자열(가변형) ==> 최대 4000byte
    char :                       문자,문자열(고정형) ==> 2000byte
    date :                       날짜형
    clob :                       문자열 ===> 최대4GB
    blob                         바이너리형(그림,음악,동영상..)  ===> 최대4GB  

  - 제약조건
     not null :  해당컬럼에 NULL을 포함되지 않도록 함         (컬럼)
     unique  :  해당컬럼 또는 컬럼 조합값이 유일하도록 함   (컬럼,테이블)
     primary key : 각 행을 유일하게 식별할수 있도록함         (컬럼,테이블)
     references  table(column)                                               
             : 해당 컬럼이 참조하고 있는 (부모)테이블의 특정   (컬럼,테이블)
               컬럼값들과 일치하거나 또는 NULL이 되도록
               보장함
     check : 해당컬럼에 특정 조건을 항상 만족시키도록함    (컬럼, 테이블)
     [참고]  primary key = unique + not null

     ex)       idx                   일련번호            primary key   
                 id                    아이디                unique 
               name                 이름                  not null 
               phone                전화번호          
               address             주소      
               score                 점수                 check
               subject_code     과목코드         
               hire_date           입학일              기본값(오늘날짜)
               marriage            결혼                 check    
             ---------------------------------------------------------------------
    - 제약조건확인
      constraint_name:이름
      constraint_type:유형
                p:primary key 
                u:unique 
                r:reference 
                c:check, not null

      search_condition :  check조건 내용
      r_constraint_name : 참조테이블의 primary key 이름
      delete_rule : 참조테이블의 primary key 컬럼이 삭제될때 적용되는 규칙
                           (no action, set null, cascade등)


     - 삭제 RULE
       on delete cascade:대상 데이터를 삭제하고,해당 데이터를 참조하는 데이터도 삭제
       on delete set null:대상 데이터를 삭제하고,해당 데이터를 참조하는 데이터는 
                          NULL로 바꿈
       on delete restricted:삭제대상 데이터를 참조하는 데이터가 존재하면 삭제할수 
                            없음(기본값)

     - 수정 RULE
       on update cascade:대상 데이터를 수정하면,해당 데이터를 참조하는 데이터도 수정
---------------------------------------------------------------------------------
[테이블수정]
-구문-
alter  table 테이블명 
add    컬럼명  데이터타입 [제약조건]
add    constraint  제약조건명  제약조건타입(컬럼명)
modify 컬럼명 데이터타입 
drop   column  컬럼명 [cascade constraints]
drop   primary key [cascade] | union (컬럼명,.....) [cascade] .... | constraint 
제약조건명 [cascade]

-이름변경-
alter table  기존테이블명  rename to  새테이블명
rename  기존테이블명  to 새테이블명

alter table 테이블명 rename column  기존컬럼명 to 새컬럼명
alter table 테이블명 rename constraint 기존제약조건명 to 새제약조건명
---------------------------------------------------------------------------------
[테이블복사]
  - 서브쿼리를 이용한 테이블생성및 행(레코드)복사
  - 서브쿼리를 이용해서 복사한경우 not null을 제외한 제약조건은 복사안됨
    (not null제약조건도  sys_*****로 복사됨)

- 구문 - 
create table 테이블명([컬럼명1,컬럼명2.....]) as 서브쿼리  

- 구조만복사 - 
create table 테이블명1 
as  select  *  from 테이블명2  where 1=0
---------------------------------------------------------------------------------
[시퀀스]
 : 순차적으로 정수값을 자동으로 생성하는 객체

create  sequence  시퀀스명
[increment by 증가값] [start with 시작값]
[maxvalue  최대값 | minvalue  최소값]
[cycle | nocycle]
[cache | nocache]

  - increment  by  증가값 : 증가/감소 간격(기본값 : 1)
  - start with : 시작번호(기본값 : 1)
  - maxvalue / minvalue : 시퀀스의 최대/최소값지정
  - cycle/nocycle : 최대/최소값에 도달시 반복여부결정
  - cache / nocache : 지정한수량만큼 메모리 생성여부결정 (최소값 : 2, 기본값 : 20)

---------------------------------------------------------------------------------
[ insert ]
 : 테이블에 데이터(새로운행)추가

insert into 테이블명 [ (column1, column2, .....)]   values (value1,value2,.....)
 -  column과 values의 순서일치
 -  column과 values의  개수 일치

---------------------------------------------------------------------------------
[ update ]
 : 테이블에 포함된 기존 데이터수정
   전체 데이터 건수(행수)는 달라지지 않음
   조건에 맞는 행(또는 열)의 컬럼값을 갱신할수 있다

update 테이블명  set  컬럼명1=value1, 컬럼명2=value2 ..... [where  조건절]
   - where 이 생략이 되면 전체행이 갱신
   - set절은 서브쿼리사용가능, default옵션 사용가능 
---------------------------------------------------------------------------------
[ delete ]
 : 테이블에 포함된 기존데이터를 삭제
   행 단위로 삭제되므로 전체행수가 달라짐
   
delete [from] 테이블명 [where  조건절];
 - where을 생략하면 전체행이 삭제됨
 - 데이터는 삭제되고 테이블 구조는 유지됨

---------------------------------------------------------------------------------
[ tracnsation처리 ]
  : 일의 시작과 끝이 완벽하게 마무리(commit)
    처리도중 인터럽트(interrupt:장애)가 발생하면 되돌아옴(rollback)
======================================================
ex1) 테이블 : test 
id   number(5), name char(10),  address varchar2(50);

create table test(
id number(5),               
name char(10),
address varchar2(50));

id 컬럼    --->  usr 컬럼으로 변경
alter table test rename column id to usr;

test 테이블  --> exam테이블로 변경
alter table test rename to exam;

exam테이블을 삭제하고 휴지통비우기 / exam테이블을 휴지통에 넣지 않고 바로 삭제
drop table exam;
purge recyclebin;

drop table exam purge;
ex2) 테이블명 : user1
create table user1(
idx     number  primary key,
id      varchar2(10) unique,
name    varchar2(10) not null,
phone   varchar2(15),
address varchar2(50),
score   number(6,2)  check(score >=0 and score <= 100),
subject_code  number(5),
hire_date  date default sysdate,
marriage   char(1)  default 'N'  check(marriage in('Y','N')));

ex3) 제약조건확인
select  constraint_name, constraint_type
from user_constraints
where table_name='USER1';

1	SYS_C004081	C
2	SYS_C004082	C
3	SYS_C004083	C
4	SYS_C004084	P
5	SYS_C004085	U

ex4) 테이블명 : user2
create table user2(
idx     number        constraint PKIDX primary key,
id      varchar2(10)  constraint UNID unique,
name    varchar2(10)  constraint NOTNAME not null,
phone   varchar2(15),
address varchar2(50),
score   number(6,2)   constraint CKSCORE check(score >=0 and score <= 100),
subject_code  number(5),
hire_date  date default sysdate,
marriage   char(1)  default 'N' constraint CKMARR check(marriage in('Y','N')));

ex5) 제약조건확인
select  constraint_name, constraint_type
from user_constraints
where table_name='USER2';

1	NOTNAME       C
2	CKSCORE       C
3	CKMARR	        C
4	PKIDX	        P
5	UNID	        U

ex6) 추가
insert into user1(idx,id,name,phone,address,score,subject_code,hire_date,marriage)
values(1,'aaa','kim','010-000-0000','서울',75,100,'2010-08-01','Y');
--->성공

insert into user1(idx,id,name,phone,address,score,subject_code,hire_date,marriage)
values(1,'aaa','kim','010-000-0000','서울',75,100,'2010-08-01','Y');
--->  무결성제약조건에 위배(이유: idx  1 중복)

insert into user1(idx,id,name,phone,address,score,subject_code,hire_date,marriage)
values(2,'aaa','kim','010-000-0000','서울',75,100,'2010-08-01','Y');
--->  무결성제약조건에 위배(이유: id  aaa 중복)

insert into user1(idx,id,name,phone,address,score,subject_code,hire_date,marriage)
values(2,'bbb', ,'010-000-0000','서울',75,100,'2010-08-01','Y');
---> 값의수가 충분하지 않습니다(이유: name 은 null허용 않는다)
     or  누락된 표현식

insert into user1(idx,id,name,phone,address,score,subject_code,hire_date,marriage)
values(2,'bbb','lee','010-000-0000','서울',120,100,'2010-08-01','Y');
---> 체크제약조건에 위배되었습니다(이유: score가 0~100사이의 수 이어야함)

insert into user1(idx,id,name,phone,address,score,subject_code,hire_date,marriage)
values(2,'bbb','lee','010-000-0000','서울',75,100,'2010-08-01','K');
---> 체크제약조건에 위배되었습니다(이유:marriage가 Y 또는 N이어야함) 

insert into user1(idx,id,name,phone,address,score,subject_code,hire_date,marriage)
values(2,'bbb','lee','010-000-0000','서울',75,100,'2010-08-01','N');
---> 성공

ex7) 테이블목록확인
select * from tab;

ex8) 테이블의 내용확인
select * from user1;
select * from user2;

ex9) 테이블의 구조확인
desc user1 (= describe user1)

ex10) 제약조건의 이름을 생성하지 않은경우(SYS_*******표시됨)
select constraint_name,constraint_type
from user_constraints
where table_name='USER1';

ex11) 제약조건의 이름을 생성한 경우(제약조건이름_******로 표시됨)
select constraint_name,constraint_type
from user_constraints
where table_name='USER2';

ex12) 테이블명 변경 : test ==> user3
alter table test rename to user3;

ex13) 컬럼추가 :  user3  == > phone  varchar2(15)
alter table user3 add phone varchar2(15);
desc user3;

ex14) 제약조건추가 : user3  ==>  id에  unique ,제약조건명 UID2
alter table user3 add constraint UID2 unique(id);

ex15)  컬럼추가 : user3 ==> no  number  (PK설정)
alter table user3 add  no number primary key;

ex16) 구조변경 : user3 ==> name  char(10) 를 varchar2(10)로 바꿈
alter table user3 modify name varchar2(10);

ex17) 컬럼삭제 : user3 ==> address
alter table user3 drop column address;

ex18) 테이블삭제 / 휴지통비우기: user3
drop table user3;
purge recyclebin;

==> drop table user3 purge(휴지통에 넣지 않고 바로 삭제)
==> flashback  table user3 to before drop;(휴지통에서 되살리기)

ex19) 시퀀스생성 / 삭제
create sequence  idx_sql increment by 2 start with 1 maxvalue  9  cycle nocache;

select  idx_sql.nextval  from dual;    ---> 다음 시퀀스값표시(nextval)
select  idx_sql.currval  from dual;    ---> 현재 시퀀스값표시(currtval)
drop sequence idx_sql;

ex20) 테이블생성과 시퀀스적용
create  table  book(
no  number primary key,
subject  varchar2(50),
price number,
year date);

create sequence  no_seq  increment by 1 start with 1  nocycle  nocache;

insert into book(no,subject,price,year) 
values(no_seq.nextval, '오라클무작정따라하기',10000,sysdate);

insert into book(no,subject,price,year) 
values(no_seq.nextval, '자바3일완성',15000,'2007-03-01');

insert into book  values(no_seq.nextval, 'JSP달인되기',18000,'2010-01-01');

insert into book(no,subject) values(no_seq.nextval,'오라클의 신');

select * from book;


ex21) 테이블 구조만 복사

create table user3
as select * from user2 where 1=0;

desc user3;                 <--- 컬럼명은 그대로 복사 

select  constraint_name, constraint_type,search_condition
from user_constraints
where table_name='USER3'    <--- not null을 제외하고는 제약조건이 복사 안됨
                                 not null제약조건도  sys_*****로 복사됨 

select * from user3;        <--- 내용없음을 확인

ex22) 테이블(idx->bunho,  name -> irum,  address -> juso) 을 복사하고  
id가  bbb인 레코드를 복사하시오
원본테이블 : user1   / 사본테이블 : user4

create table user4(bunho,irum,juso)
as select idx,name,address from user1 where id='bbb';

select * from user4;
